<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Geometry Dash Clone</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100vh;
            touch-action: none;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4d4d;
            font-size: 2em;
            text-align: center;
            display: none;
            text-shadow: 2px 2px 4px #000;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 1.5em;
            text-shadow: 1px 1px 2px #000;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="gameOver">Game Over! Tap/Space to Restart</div>
    <div id="score">Score: 0</div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverDiv = document.getElementById('gameOver');
        const scoreDiv = document.getElementById('score');

        // Responsive canvas sizing
        function resizeCanvas() {
            const aspectRatio = 16 / 9;
            const maxWidth = window.innerWidth;
            const maxHeight = window.innerHeight;
            let width = maxWidth;
            let height = width / aspectRatio;
            if (height > maxHeight) {
                height = maxHeight;
                width = height * aspectRatio;
            }
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Game variables
        let player = {
            x: 100,
            y: 0,
            size: 30,
            vy: 0,
            rotation: 0,
            gravity: 0.8,
            jumpPower: -15,
            isGrounded: false,
            gravityDirection: 1
        };
        let obstacles = [];
        let portals = [];
        let particles = [];
        let cameraX = 0;
        let cameraShake = 0;
        let gameSpeed = 6;
        let score = 0;
        let isGameOver = false;
        let lastObstacleX = 0;
        const groundHeight = 50;
        const frameTime = 1 / 60;

        // Audio setup
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let oscillator = null;

        function playMusic() {
            if (oscillator) oscillator.stop();
            oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start();
            const notes = [440, 494, 523, 587, 659, 698, 784];
            let noteIndex = 0;
            function changeNote() {
                oscillator.frequency.setValueAtTime(notes[noteIndex % notes.length], audioCtx.currentTime);
                noteIndex++;
                setTimeout(changeNote, 150);
            }
            changeNote();
        }

        // Generate random level
        function generateLevel() {
            obstacles = [];
            portals = [];
            lastObstacleX = canvas.width;
            const segmentLength = 150;
            for (let i = 0; i < 15; i++) {
                const x = lastObstacleX + segmentLength;
                const type = Math.random();
                let segmentWidth = 0;
                if (type < 0.5) { // Spikes
                    const spikeCount = Math.floor(Math.random() * 3) + 1;
                    for (let j = 0; j < spikeCount; j++) {
                        obstacles.push({
                            x: x + j * 30,
                            y: player.gravityDirection > 0 ? canvas.height - groundHeight : 0,
                            width: 30,
                            height: 30,
                            type: 'spike'
                        });
                    }
                    segmentWidth = spikeCount * 30;
                } else { // Platforms
                    const platformHeight = Math.random() < 0.2 ? 40 : 20; // Occasional double-height platforms
                    obstacles.push({
                        x: x,
                        y: canvas.height - groundHeight - (Math.random() * 100 + 50),
                        width: 100 + Math.random() * 50,
                        height: platformHeight,
                        type: 'platform'
                    });
                    segmentWidth = 100 + Math.random() * 50;
                }
                if (Math.random() < 0.3) {
                    portals.push({
                        x: x + 50,
                        y: canvas.height / 2 - 30,
                        width: 30,
                        height: 60,
                        type: 'gravity'
                    });
                }
                lastObstacleX = x + segmentWidth; // Fixed: Use segmentWidth
            }
        }

        // Particle system for death effect
        function createParticles(x, y) {
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: x + player.size / 2,
                    y: y + player.size / 2,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    size: Math.random() * 5 + 5,
                    life: 1
                });
            }
        }

        // Reset game
        function resetGame() {
            player.x = 100;
            player.y = canvas.height - groundHeight - player.size;
            player.vy = 0;
            player.rotation = 0;
            player.gravityDirection = 1;
            player.isGrounded = true;
            cameraX = 0;
            cameraShake = 0;
            score = 0;
            gameSpeed = 6;
            isGameOver = false;
            gameOverDiv.style.display = 'none';
            particles = [];
            generateLevel();
            playMusic();
        }

        // Input handling
        function jump() {
            if (player.isGrounded && !isGameOver) {
                player.vy = player.jumpPower * player.gravityDirection;
                player.isGrounded = false;
            }
            if (isGameOver) {
                resetGame();
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') jump();
        });

        canvas.addEventListener('touchstart', jump);

        // Update game
        function update() {
            if (isGameOver) return;

            // Physics
            player.vy += player.gravity * player.gravityDirection;
            player.y += player.vy;
            player.rotation = player.isGrounded ? 0 : player.rotation + player.vy * 0.05; // Smoother rotation
            player.isGrounded = false;

            // Ground/Ceiling collision
            if (player.gravityDirection > 0) {
                if (player.y > canvas.height - groundHeight - player.size) {
                    player.y = canvas.height - groundHeight - player.size;
                    player.vy = 0;
                    player.isGrounded = true;
                    player.rotation = 0;
                }
            } else {
                if (player.y < player.size) {
                    player.y = player.size;
                    player.vy = 0;
                    player.isGrounded = true;
                    player.rotation = 0;
                }
            }

            // Camera and progression
            cameraX += gameSpeed;
            score += gameSpeed / 60;
            scoreDiv.textContent = `Score: ${Math.floor(score)}`;

            // Collision with obstacles
            for (let obs of obstacles) {
                const obsX = obs.x - cameraX;
                if (player.x + player.size > obsX &&
                    player.x < obsX + obs.width &&
                    player.y + player.size > (obs.type === 'spike' ? (player.gravityDirection > 0 ? canvas.height - groundHeight - obs.height : 0) : obs.y) &&
                    player.y < (obs.type === 'spike' ? (player.gravityDirection > 0 ? canvas.height - groundHeight : obs.height) : obs.y + obs.height)) {
                    if (obs.type === 'platform' && player.vy * player.gravityDirection > 0 &&
                        player.y + player.size <= obs.y + 5) {
                        player.y = obs.y - player.size;
                        player.vy = 0;
                        player.isGrounded = true;
                        player.rotation = 0;
                    } else if (obs.type === 'spike') {
                        isGameOver = true;
                        gameOverDiv.style.display = 'block';
                        createParticles(player.x, player.y);
                        cameraShake = 5; // Reduced for subtler effect
                        if (oscillator) oscillator.stop();
                    }
                }
            }

            // Portal collision
            for (let i = portals.length - 1; i >= 0; i--) {
                const portal = portals[i];
                const portalX = portal.x - cameraX;
                if (player.x + player.size > portalX &&
                    player.x < portalX + portal.width &&
                    player.y + player.size > portal.y &&
                    player.y < portal.y + portal.height) {
                    player.gravityDirection *= -1;
                    player.vy = 0;
                    player.y = player.gravityDirection > 0 ? canvas.height - groundHeight - player.size : player.size;
                    player.isGrounded = true;
                    cameraShake = 5;
                    portals.splice(i, 1);
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                if (p.life <= 0) particles.splice(i, 1);
            }

            // Camera shake
            if (cameraShake > 0) cameraShake -= 0.2; // Faster decay

            // Generate new level segments
            if (lastObstacleX - cameraX < canvas.width * 2) {
                generateLevel();
            }
        }

        // Render game
        function render() {
            ctx.fillStyle = '#162447';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Animated background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 0; i < 20; i++) {
                const x = (i * 100 - cameraX * 0.5) % (canvas.width + 100) - 100;
                ctx.fillRect(x, 0, 50, canvas.height);
            }

            // Ground
            ctx.fillStyle = '#0f3460';
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
            if (player.gravityDirection < 0) {
                ctx.fillRect(0, 0, canvas.width, groundHeight);
            }

            // Player with rotation
            ctx.save();
            ctx.translate(player.x + player.size / 2, player.y + player.size / 2);
            ctx.rotate(player.rotation);
            ctx.fillStyle = '#e94560';
            ctx.fillRect(-player.size / 2, -player.size / 2, player.size, player.size);
            ctx.restore();

            // Obstacles
            for (let obs of obstacles) {
                const obsX = obs.x - cameraX + (Math.random() * cameraShake);
                if (obsX + obs.width < 0 || obsX > canvas.width) continue;
                if (obs.type === 'spike') {
                    ctx.fillStyle = '#ff4d4d';
                    ctx.beginPath();
                    if (player.gravityDirection > 0) {
                        ctx.moveTo(obsX, canvas.height - groundHeight);
                        ctx.lineTo(obsX + obs.width / 2, canvas.height - groundHeight - obs.height);
                        ctx.lineTo(obsX + obs.width, canvas.height - groundHeight);
                    } else {
                        ctx.moveTo(obsX, 0);
                        ctx.lineTo(obsX + obs.width / 2, obs.height);
                        ctx.lineTo(obsX + obs.width, 0);
                    }
                    ctx.fill();
                } else {
                    ctx.fillStyle = '#533483';
                    ctx.fillRect(obsX, obs.y, obs.width, obs.height);
                }
            }

            // Portals with glow effect
            for (let portal of portals) {
                const portalX = portal.x - cameraX;
                if (portalX + portal.width < 0 || portalX > canvas.width) continue;
                ctx.fillStyle = `rgba(0, 255, 255, ${0.5 + Math.sin(Date.now() / 200) * 0.2})`;
                ctx.fillRect(portalX, portal.y, portal.width, portal.height);
                // Glow effect
                ctx.fillStyle = `rgba(0, 255, 255, ${0.2 + Math.sin(Date.now() / 200) * 0.1})`;
                ctx.fillRect(portalX - 10, portal.y - 10, portal.width + 20, portal.height + 20);
            }

            // Particles
            ctx.fillStyle = '#e94560';
            for (let p of particles) {
                ctx.beginPath();
                ctx.arc(p.x - cameraX, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Game loop
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        resetGame();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>